# Лабораторная работа 1 :train2:

[![forthebadge made-with-python](http://ForTheBadge.com/images/badges/made-with-python.svg)](https://www.python.org/)

[![GitHub release](https://img.shields.io/badge/version-v1.0-red)](https://img.shields.io/badge/version-v1.0-red)
[![Contributor](https://img.shields.io/badge/contributors-4-blue)](https://img.shields.io/badge/contributors-4-blue)


## Описание
В это работе мы имплементировали алгоритм [k-Nearest Neighbours](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm)  для определения напитка ( :tea: или :coffee: ), который предпочтут на станции метро. 



Наша обучающая выборка состояла из 9 станций московского метро с указанием напитка, который на ней предпочитают. Таблица с учебной выборкой хранится в файле ```data/data.csv``` . Напиток - бинарный параметр кофе или чай.



В качестве метрики мы использовали время, которое надо потратить для того что бы добраться с классифицируемой станции до некоторого количества станций из обучающей выборки. Для расчета времени используется сервис Яндекс.Метро, для парсинга выдачи этого ресурса используется библиотека ```selenium``` .  Код парсера можно найти в файле  ``parse.py`` . После того как собрано время от каждой из 9 учебных станций до каждой станции метро (эта таблица находится в файле ``data/metroMatrix.csv``), мы можем просто селектить нужную станцию и смотреть на метрику для неё. Такой подход был выбран для того чтобы не посылать запросы динамически, что увеличивает время работы скрипта, а однажды собрать все данные и просто агрегировать их для каждой станции.



Код алгоритма находится в файле ``knn.py``. Он представляет собой класс с несколькими методами.



Для запуска скрипта надо в файле ``run.py`` указать станцию, напиток которой мы хотим определить. Пример: ``POINT = "Электрозаводская"`` . После чего запустить этот файл с помощью ``python3 run.py``. Результат работы будет представлен в терминале.

## Необходимые библиотеки
- ``selenium==3.141.0``
- ``pandas==1.1.1``
- ``numpy``

## Детальное описание :computer:

Сперва происходит сбор данных в parse.py.  Используем Selenium, чтобы забирать данные с Yandex.Metro. Формируем dataframe и сохраняем его в .csv. В качестве индексов строк выбраны станции из тренировочного набора данных. Таким образом при обращении к dataframe[станция метро] возвращается список расстояния до 9 станций, которые находятся в тренировочном наборе данных. Потом можно сопоставить лейблы для полученных строк - кофе/чай и получить индексы отсортированных расстояний (argsort). Затем просто посчитать среднее значение первых отсортированных K лейблов.  Если меньше 0.5, то класс - 0, если больше - 1.  В run.py нужно указать станцию метро.
